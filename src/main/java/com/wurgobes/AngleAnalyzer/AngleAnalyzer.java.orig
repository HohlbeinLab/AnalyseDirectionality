package com.wurgobes.AngleAnalyzer;

/*
Angle Analyzer
(c) 2022 Martijn Gobes, Wageningen University.


This software is released under the GPL v3. You may copy, distribute and modify
the software as long as you track changes/dates in source files. Any
modifications to or software including (via compiler) GPL-licensed code
must also be made available under the GPL along with build & install instructions.
https://www.gnu.org/licenses/gpl-3.0.en.html

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */


import gui_orientation.Credits;
import gui_orientation.Help;
import gui_orientation.WalkBarOrientationJ;
import gui_orientation.components.GridPanel;
import gui_orientation.components.GridToolbar;
import gui_orientation.components.Settings;
import gui_orientation.components.SpinnerDouble;
import ij.*;
import ij.gui.*;
import ij.plugin.frame.Recorder;
import ij.process.ColorProcessor;
import ij.process.ImageConverter;
import ij.process.ImageProcessor;
import net.imagej.ImageJ;
import net.imagej.lut.LUTService;
import net.imglib2.type.numeric.RealType;
import org.apache.commons.lang3.tuple.Pair;
import org.scijava.Priority;
import org.scijava.command.Command;
import org.scijava.log.LogService;
import org.scijava.plugin.Parameter;
import org.scijava.plugin.Plugin;


import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;

import static com.wurgobes.AngleAnalyzer.AnalyzerFunctions.*;
import static com.wurgobes.AngleAnalyzer.util.*;


@Plugin(type = Command.class, name = "Angle Analyzer", menuPath = "Plugins>Angle Analyzer>Analyze Angles", priority = Priority.HIGH)
public class AngleAnalyzer <T extends RealType<T>> implements Command {

    // The services are passed through from ImageJ automatically

    @Parameter
    private LogService logService;

    @Parameter
    private LUTService lutService;


    /** The ImagePlus this plugin operates on. */
    //@Parameter(label="Image to process")
    //protected Dataset dataset;

    //@Parameter(type = ItemIO.OUTPUT)
    //private Dataset result;

    private ImagePlus imp;

    /* private variables */
    private static boolean debugging = false;

    private OwnColorTable circularLut; // Class to load LUT's
    private OwnColorTable orderLUT; // Class to load LUT's

    /* Directionality stuff */

    //x, y, width, height, index, median, angle, FT data
    ArrayList<ArrayList<Double>> csv_data = new ArrayList<>();
    ArrayList<Boolean> sig_map = new ArrayList<>();
    ArrayList<Double> adjusted_stats = new ArrayList<>();
    ArrayList<Double> angle_map = new ArrayList<>();
    ImageStack fft_stack = null;
    ImagePlus fft_imp = null;
    Plot hist_alt = new Plot("Angles", "Angle", "Intensity (a.u)");
    Plot order_plot = new Plot("Order", "Neighbourhood Size", "Avg Order");
    ArrayList<Roi> rois = new ArrayList<>();
    Overlay overlay = new Overlay();


    ImagePlus order_imp = null;

    int width;
    int height;
    int map_width = -1;

    ImagePlus mask = null;
    ImagePlus sig_mask = null;
    ImagePlus max_imp = null;

    RAFTParameters params = new RAFTParameters();

    static String macro_params = null;



    @Override
    public void run() {
        circularLut = new OwnColorTable(lutService);
        circularLut.setLut("physics.lut");

        orderLUT = new OwnColorTable(lutService);
        orderLUT.setLut("winter");

        if(imp == null)
            imp = WindowManager.getCurrentImage();

        logService.info("Angle Analyzer 1.0. Processing Image: " + imp.getTitle());



        width = imp.getWidth();
        height = imp.getHeight();

        params.width = width;
        params.height = height;

        hist_alt.savePlotObjects();
        order_plot.savePlotObjects();


        // Mask
        mask = imp.duplicate();
        mask.setTitle("Mask");
        util.MakeMask(mask);
        ImageConverter converter = new ImageConverter(mask);
        converter.convertToGray8();

        imp.setOverlay(overlay);

        if (macro_params == null)
            macro_params = Macro.getOptions();


        if (macro_params != null && !macro_params.isEmpty()) {
            params.getMacroParameters(macro_params);
            new RAFTDialogue<>(this, params);
        }
        else {
            RAFTDialogue<T> raftDialogue = new RAFTDialogue<>(this, params);
            raftDialogue.showDialog();
        }


	}

<<<<<<< Updated upstream
    public void saveData(){
        String path = "C:\\Users\\gobes001\\source\\repos\\Scratch\\ATF stuff analysis\\input\\" + imp.getShortTitle() + ".csv";
        logService.info("Saving to " + path);
        SaveCSV(csv_data, new ArrayList<>(Arrays.asList("x", "y", "width", "height", "Max Index", "Mask Median", "Angle", "Relevance?", "Profile Data")), Paths.get(path));
=======
    public void saveData(RAFTParameters params){
        logService.info("Saving to: W:\\Data\\Microscopy\\Airyscan\\2023\\Deadstop Moisture\\Deadstop 1\\Saggital\\" + params.window + "_" + imp.getShortTitle()+".csv");
        SaveCSV(csv_data, new ArrayList<>(Arrays.asList("x", "y", "width", "height", "Max Index", "Mask Median", "Angle", "Relevance?", "Profile Data")), Paths.get("W:\\Data\\Microscopy\\Airyscan\\2023\\Deadstop Moisture\\Deadstop 1\\Saggital\\","window" + params.window + "_" + imp.getShortTitle()+".csv"));
>>>>>>> Stashed changes
    }

    public void runVector(RAFTParameters params){
        if(params.window % 2 == 0)
            params.window += 1;
        //Non stack version for now
        if(false && imp.hasImageStack()){
            ImageStack input = imp.getStack();
            ImageStack imageStack = new ImageStack();
            System.out.println(imageStack.getSize());
            for(int i=0; i < input.getSize(); i++){
                System.out.println("Processing slice " + i);
                IJ.showStatus(String.format("Processing %d/%d", i, input.getSize()));
                ImagePlus dummy = new ImagePlus("dummy", input.getProcessor(i+1));
                ImageProcessor allpeaks = util.obtainDistancesFFT(dummy, 0.005f);
                imageStack.addSlice(String.valueOf(i), allpeaks);
            }
            ImagePlus result = new ImagePlus("FFT", imageStack);
            result.show();
        } else {

            if(!params.macro_mode){
                ColorProcessor max_ip = new ColorProcessor(width, height);
                if (max_imp == null)
                    max_imp = new ImagePlus("Colored blocks", max_ip);
                else
                    max_imp.setProcessor(max_ip);


                max_imp.show();
            }

            calculateAngles(params);
        }
        params.firstResults = Boolean.TRUE;

        if(params.macro_mode)
            saveData(params);

        logService.info("Angle Analyzing Done");
    }

    public void calculateAngles(RAFTParameters params){
        csv_data.clear();
        angle_map.clear();
        Pair<Integer, ImageStack> pair = AnalyzerFunctions.run(imp, max_imp, mask, csv_data, angle_map, circularLut, params);
        map_width = pair.getLeft();
        fft_stack = pair.getRight();

        if(!params.macro_mode){
            if(fft_imp == null)
                fft_imp = new ImagePlus("ffts", fft_stack);
            else
                fft_imp.setStack(fft_stack);

            fft_imp.show();
            addLutLegend(max_imp.getProcessor(), circularLut, "Angle", 1024, 0f, 180f);
            max_imp.repaintWindow();
        }

        calculateVectorField(params);
        calculateOrder(params);

        if(!params.macro_mode) {
            AngleGraph(params);
            hist_alt.show();
        }
    }

    public void calculateVectorField(RAFTParameters params){

        adjusted_stats.clear();
        calc_adjusted_stats(adjusted_stats, csv_data);
        applyVectorField(params);
    }

    public void applyVectorField(RAFTParameters params){
        rois.clear();

        calcVectorMap(rois, csv_data, params);
        applyOverlay(imp, overlay, rois, params);
    }

    public void calculateOrder(RAFTParameters params){
        sig_map.clear();
        order_plot.restorePlotObjects();
        ImageProcessor sig_ip = calcSigMap(csv_data, sig_map, params);
        ImageStack order_stack = order_parameter(csv_data, angle_map, sig_map, orderLUT, order_plot, map_width, width, height, params.window);


        if(!params.macro_mode){
            if(order_imp == null)
                order_imp = new ImagePlus("order_parameter", order_stack);
            else
                order_imp.setStack(order_stack);

            if(sig_mask == null)
                sig_mask = new ImagePlus("Intensity Cutoff Mask", sig_ip);
            else
                sig_mask.setProcessor(sig_ip);

            order_plot.setLimitsToFit(Boolean.TRUE);
            order_plot.show();

            if(order_imp.isVisible())
                order_imp.updateAndRepaintWindow();
            else
                order_imp.show();

            if(sig_mask.isVisible())
                sig_mask.updateAndRepaintWindow();
            else
                sig_mask.show();
        }
    }

    public void toggleOverlay(){
        toggle_overlay(imp, overlay);
    }

    public void AngleGraph(RAFTParameters params){
        hist_alt.restorePlotObjects();
        createAngleGraph(fft_stack, csv_data, params.cutoff, hist_alt);
    }

    public void scanWindow(RAFTParameters params){
        params.scanning_range = Boolean.TRUE;
        ImageStack angle_stack = null;
        ImageStack order_graph_stack = null;
        for(int i = params.start; i <= params.end; i+=params.step){
            // For each window collect the angle dist and the order graph
            params.window = i;
            runVector(params);

            if (angle_stack == null)
                angle_stack = new ImageStack(hist_alt.getProcessor().getWidth(), hist_alt.getProcessor().getHeight());
            if (order_graph_stack == null)
                order_graph_stack = new ImageStack(order_plot.getProcessor().getWidth(), order_plot.getProcessor().getHeight());

            angle_stack.addSlice("window " + i, hist_alt.getProcessor().duplicate());
            order_graph_stack.addSlice("window " + i, order_plot.getProcessor().duplicate());
        }

        ImagePlus angle_window_sweep = new ImagePlus("Angle vs Window", angle_stack);
        ImagePlus order_window_sweep = new ImagePlus("Order vs Window", order_graph_stack);
        angle_window_sweep.show();
        order_window_sweep.show();
    }

    // Only run from the IDE
    public static void main(final String... arguments) {
        debugging = true;
        ImageJ ij = new ImageJ();
        ij.ui().showUI();

        //macro_params = "buffer=0 window=250 overlap=0.5";
        ImagePlus imp = new ij.io.Opener().openImage("W:\\Data\\Microscopy\\Airyscan\\2023\\Deadstop Moisture\\Deadstop 1\\Saggital\\protein.tif");


        imp.show();
        ij.command().run(AngleAnalyzer.class, true);
    }
}


}

<<<<<<< Updated upstream
=======
class RAFTParameters {

    public boolean				showVectorOverlay		= true;
    public boolean              macro_mode = false;

    public int					vectorGrid				= 10;
    public double				vectorScale				= 100;
    public int					vectorType				= 0;

    public double				buffer				= 0.0;
    public int				window				= 25;
    public double				cutoff			= 2;
    public double				overlap             = 0.75;
    public double				intensity_cutoff             = 0.2;
    public double vector_length;
    public double vector_width;

    public int width;
    public int height;

    public boolean firstResults = Boolean.FALSE;

    public Color vector_color = new Color(255, 227, 0);
    public int start = 17;
    public int end = 101;
    public int step = 2;

    public boolean scanning_range = Boolean.FALSE;


    public void getMacroParameters(String options) {
        macro_mode = true;
        //Own stuff
        buffer = Integer.parseInt(Macro.getValue(options, "buffer", "0"));
        window = Integer.parseInt(Macro.getValue(options, "window", "75"));
        cutoff = Double.parseDouble(Macro.getValue(options, "cutoff", "2"));
        overlap = Double.parseDouble(Macro.getValue(options, "overlap", "0.75"));
        intensity_cutoff = Double.parseDouble(Macro.getValue(options, "intensity_cutoff", "0.2"));

        // Vector Field
        showVectorOverlay = Macro.getValue(options, "vectoroverlay", "on").equals("on");
        vectorGrid = Integer.parseInt(Macro.getValue(options, "vectorgrid", "10"));
        vectorScale = Double.parseDouble(Macro.getValue(options, "vectorscale", "100"));
        vectorType = Integer.parseInt(Macro.getValue(options, "vectortype", "0"));
    }



}
>>>>>>> Stashed changes
